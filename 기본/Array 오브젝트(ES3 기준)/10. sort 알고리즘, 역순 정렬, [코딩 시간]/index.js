/**
 * sort()
 * - sort 알고리즘 [코드1]
 */
console.log("[코드1] sort 알고리즘");
let value = [101, 26, 7, 1234];
value.sort(function (one, two) {
  return one - two;
})
console.log(value); // [7, 26, 101, 1234]
/**
 * 1. sort() 파라미터의 function(){}을 호출하면서
 *    101과 26을 파라미터 값으로 넘깁니다.
 *    101이 one에, 26이 two에 설정됩니다.
 * 2. one(101) - two(26)의 결과는 양수이며
 *    이 값을 반환합니다.
 * 3. 이때, 0보다 큰 값이 반환되면
 *    배열에서 값의 위치를 바꿉니다.
 *    즉, [26, 101, 7, 1234]가 됩니다.
 * 4. 다시 콜백 함수를 호출하면서 101과 7을 넘겨줍니다.
 *    one(101) - two(7)의 결과는 양수이며
 *    0보다 큰 값을 반환하게 됩니다.
 * 5. 반환 값이 0보다 크므로
 *    배열에서 값의 위치를 바꿉니다.
 *    즉, [26, 7, 101, 1234]가 됩니다.
 * 6. 다시 함수를 호출하면서 101과 1234를 넘겨줍니다.
 *    one(101) - two(1234)의 결과는 음수이며
 *    0보다 작은 값을 반환하게 됩니다.
 * 7. 반환 값이 0보다 작거나 같으면
 *    배열에서 값의 위치를 바꾸지 않습니다.
 *    따라서, [26, 7, 101, 1234]가 됩니다.
 * 8. 다시 처음으로 돌아가 바뀌는 것이 없을 때까지
 *    배열의 엘리먼트 위치를 조정합니다.
 */

/**
 * [코딩 시간]
 * - 요구 사항
 *    let value = [101, 26, 7, 1234];
 *    배열의 엘리먼트 값을 역순으로 정렬하세요.
 * - 힌트
 *    - sort() 메소드는 역순 정렬을 제공하지 않습니다.
 *    - 하지만, sort() 메소드의 콜백 함수를 사용하여
 *      역순으로 정렬할 수 있습니다.
 *    - 앞 페이지의 sort 알고리즘을 참조하세요.
 */
console.log("[코딩 시간]");
let value2 = [101, 26, 7, 1234];
value2.sort((a, b) => b - a);
console.log(value2);

/**
 * reverse()
 *
 * 구분- 데이터(값)
 * data - 대상
 * 파라미터 - 사용하지 않음
 * 반환 - 결과
 *
 * - 배열의 엘리먼트 위치를 역순으로 바꿈
 *    - 엘리먼트 값이 아닌 인덱스 기준 [코드2]
 *    - 대상 배열도 바뀜
 */
console.log("[코드2] 인덱스 기준으로 역순");
let value3 = [1, 3, 7, 5];
console.log(value3.reverse());  // [5, 7, 3, 1]
console.log(value3);  // [5, 7, 3, 1]