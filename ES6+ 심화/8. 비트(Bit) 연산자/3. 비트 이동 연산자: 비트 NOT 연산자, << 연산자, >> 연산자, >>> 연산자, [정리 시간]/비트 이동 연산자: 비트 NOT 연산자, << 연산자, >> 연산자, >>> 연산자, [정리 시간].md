# 비트 이동 연산자

## 비트 NOT 연산자

형태: ~value

스펙에는 Bitwise로 표기되어 있지만 강좌에서는 비트로 표기합니다.

값의 사인 부호를 바꿉니다.

양수이면 음수로 변환 후, -1을 더하고

음수이면 양수로 변환 후, 1을 뺍니다.

2진수 비트로 처리합니다.

```js
console.log(~5); // -6
console.log(~-5); // 4
```

    1. 5를 -5로 변환하고 -1을 더합니다.
    2. -5를 5로 변환하고 1을 뺍니다.

## << 연산자

왼쪽 이동 연산자 (Left Shift Operator)

연산자 오른쪽에 지정한 수만큼 연산자 왼쪽 비트를 왼쪽으로 이동합니다.

```js
const value = 3;
console.log(value << 1); // 6

console.log(value << 2); // 12
```

| 비트    | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| :------ | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| 비트 값 | 128 | 64  | 32  | 16  | 8   | 4   | 2   | 1   |
| 값3     | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   |
| 1비트   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 0   |
| 2비트   | 0   | 0   | 0   | 0   | 1   | 1   | 0   | 0   |

    1. value << 1
    왼쪽으로 1비트 이동합니다.
    값이 (1 + 2)에서 (2 + 4)로 바뀝니다.

    2. value << 2
    왼쪽으로 2비트 이동합니다.
    값이 (1 + 2)에서 (4 + 8)로 바뀝니다.

    3. value << 4
    결과가 얼마일까요? 계산을 해보세요. (48)

## >> 연산자

사인 포함 오른쪽 이동 연산자 (Signed Right Shift Operator)

연산자 오른쪽에 지정한 수만큼 연산자 왼쪽 비트를 오른쪽으로 이동합니다.

왼쪽의 사인 부호는 바뀌지 않습니다.

정수만 사용하므로 소수 이하는 버립니다.

```js
const value = 10;
console.log(value >> 1); // 5
console.log(value >> 2); // 2
```

| 비트    | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| :------ | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| 비트 값 | 128 | 64  | 32  | 16  | 8   | 4   | 2   | 1   |
| 값10    | 0   | 0   | 0   | 0   | 1   | 0   | 1   | 0   |
| 1비트   | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 1   |
| 2비트   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 0   |

    1. value >> 1
    오른쪽으로 1비트 이동합니다.
    값이 (2 + 8)에서 (1 + 4)로 바뀝니다.

    2. value >> 2
    오른쪽으로 2비트 이동합니다.
    값이 (2 + 8)에서 (2)로 바뀝니다.

## >>> 연산자

사인 부호 없는 오른쪽 이동 연산자 Unsigned Right Shift Operator

사인 포함 오른쪽 이동 연산자(>>)와 같지만

MSB 사인 부호도 이동하는 점이 다릅니다.

이동한 후, MSB 사인 부호 값은 0입니다.

## [정리 시간]

목적

- 비트 연산 논리를 이해하기 위한 것 입니다.

값이 음수일 때 코드에서 값이 출력되는 논리를 정리하세요

```js
var value = -10;

console.log(value >> 1);
console.log(value >> 2);
```

    1. value 변숫값이 -10입니다.
    2. 오른쪽으로 1비트 이동하면 -5가 되고
    3. 오른쪽으로 2비트 이동하면 -3이 됩니다.

1번째,

| 비트    | 7   | 6   | 5   | 4   | 3   | 2   | 1   | 0   |
| :------ | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| 비트 값 | 1   | 64  | 32  | 16  | 8   | 4   | 2   | 1   |
| 값 -10  | 1   | 0   | 0   | 0   | 1   | 0   | 0   | 1   |
| 1비트   | 1   | 0   | 0   | 0   | 0   | 1   | 0   | 0   |
| 2비트   | 1   | 0   | 0   | 0   | 0   | 0   | 1   | 0   |

값 -10은 1000 1001

`>> 연산자` 는 MBS를 변경하지 않으므로

-10 값은 1000 1001 (-10)
여기서 1비트 이동하면 1000 0100 (-5)
2비트 이동하면 1000 0010 (-3) 으로 값이 출력됩니다.

---

2번째,

-10은 -(1010)이고 음수라서 1의 보수로 바꿔줍니다. (1은 0, 0은 1로 전환)

0101이 되고 여기서 1를 더해줍니다.

     0101
    +   1
     0110

0110으로 2의 보수가 됩니다.

하지만 비트 이동을 위해서 다시 1의 보수로 바꿔줍니다.

1001이 되고 여기서 1비트 이동하면 0100, 2비트 이동하면 0010입니다.

1비트 이동 한 값은 -(0100) + -1(MBS), 2비트 이동한 값은 -(0010) + -1(MBS)로

각각 -5, -3이 출력됩니다.
