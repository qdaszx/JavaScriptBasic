/**
 * 즉시 실행 함수
 *
 * - 함수 즉시 실행이란?
 *    - 엔진이 함수를 만났을 때
 *    - 자동으로 함수를 실행 [코드1]
 *    - 즉시에 실행하므로 즉시 실행 함수
 * - IIFE: Immediately Invoked Function Expression
 * - (function(){...}) 형태
 *    - 함수 이름이 없으르모
 *      함수 선언문, 함수 표현식도 아님
 *    - 문법 에러가 발생하지 않음
 *    - 무명 함수, 익명 함수라고도 부름
 */
console.log("[코드1] 함수 즉시 실행");
(function () {
  console.log("JS북");  // JS북
}());

/**
 * 함수 즉시 실행 과정
 *
 * - 표현식을 평가
 *    - 소괄호()는 그룹핑 연산자 [코드1]
 * - 함수 이름 필요
 *    - 함수에 이름이 없으면 문법 에러 [코드2]
 * - 함수 표현식 끝에 소괄호 작성 [코드3]
 * - 소괄호()에 함수 작성 [코드4]
 */
console.log("[코드2] 표현식 해석");
var total = (1 + 2);
console.log(total);
/**
 * 1. (1 + 2) 형태에서
 *    소괄호()는 그룹핑 연산자이며
 *    1 + 2는 표현식
 * 2. 그룹핑 연산자는 소괄호 안의 표현식을 평가하고
 *    평가 결과를 반환
 * 3. 소괄호()와 표현식 평가가 키포인트
 */

console.log("[코드3] 함수 이름 필요");
var value = function () {
  return 100;
};
console.log(value()); // 100
/**
 * 1. 함수 표현식으로
 *    엔진이 function 키워드를 만나면
 *    function 오브젝트를 생성하여 value 변수에 할당
 * 2. value 변수를 선언하지 않으면
 *    함수 이름이 없으므로 문법 에러
 *    함수 표현식도, 함수 선언문도 아니기 때문
 * 3. value()처럼 function 끝에
 *    소괄호()를 첨부하여 함수로 호출
 *    이때, 소괄호()는 그룹핑 연산자가 아닌 함수 호출
 */

console.log("[코드4] 끝에 소괄호 작성");
var value2 = function () {
  return 100;
}();
console.log(value2);  // 100
/**
 * 1. 함수 끝에 소괄호를 첨부한 형태
 * 2. function 키워드를 만나 function 오브젝트 생성
 * 3. 소괄호가 있으므로 함수 호출
 * 4. 함수에서 반환한 100을 value 변수에 할당
 */

console.log("[코드5] 소괄호()에 함수 작성");
var value3 = (function () {
  return 100;
}());
console.log(value3);  // 100
/**
 * 1. 소괄호 안에 함수 작성
 * 2. 소괄호는 그룹핑 연산자
 * 3. 그룹핑 연산자이므로 소괄호 안의 표현식을 평가
 * 4. 표현식이 함수이므로 function 오브젝트 생성
 * 5. function 끝에 소괄호가 있으므로 함수 실행
 */

/**
 * 함수 즉시 실행 과정
 *
 * - 그룹핑 연산자에서
 *   반환된 값이 할당되는 변수를 작성하지 않은 형태 [코드6]
 * - })()처럼 소괄호를 끝에 작성 가능
 */
console.log("[코드6] 값 반환을 사용하지 않음");
(function () {
  console.log(100); // 100
}());
/**
 * 1. 그룹핑 연산자를 작성하지 않으면
 *    함수 이름이 없으므로 문법 에러
 * 2. 하지만, 그룹핑 연산자를 작성하면
 *    표현식에 function을 작성한 것이므로
 *    문법 에러가 발생하지 않습니다.
 *    즉, (1 + 2)에서 1 + 2 대신에 함수를 작성한 것
 * 3. 표현식과 표현식 평가 결과는
 *    평가 결과가 반환할 때까지 메모리에 저장하고
 *    평가 결과를 반환하면 지워집니다.
 * 4. (1 + 2)의 결과가 메모리에 저장된다면
 *    매우 많은 메모리가 필요할 것입니다.
 * 5. function(){}():
 *    코드로 만든 오브젝트도 메모리에 저장되지 않으며
 *    실행 결과도 메모리에 저장되지 않습니다.
 * 6. 따라서 저장해야 할 것이 있다면
 *    표현식 밖의 변수, 프로퍼티에 저장해야 합니다.
 * 7. 저장할 필요가 없는 1회성 코드이면서
 *    엔진이 function 키워드를 만나는 시점에
 *    즉시 실행해야 한다면
 * 8. 그룹핑 연산자 안에 표현식으로 작성
 * 9. 무명 함수는 그룹핑 연산자 안의 코드를
 *    한 번만 사용할 때 사용합니다.
 *    주로 초깃값을 설정할 때 사용
 */