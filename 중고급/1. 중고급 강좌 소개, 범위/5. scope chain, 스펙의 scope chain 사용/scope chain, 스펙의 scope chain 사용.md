ES3에서는 scope chain를 쓰지만 ES5에서는 scope만 씁니다

## 동적 처리

함수가 호출되면 그 안에 변수와 함수 이름을 프로퍼티로 만들고 그것을 scope chain에 연결시킨다는 것입니다. 그러니 함수가 새로 생길 때마다 스코프 체인이 동적으로 처리 됩니다.

반면, ES5은 Lexical Environments 즉, 정적 환경에 함수 안에 변수와 함수를 설정하고 이외에 처리를 하지 않습니다.

그러면 ES3는 두번 동작이 발생하고, 한번은 정적이 아닌 함수가 생성될 때마다 동적으로 만들어 진다는 것입니다.

개념적으로 봐도 ES5처럼 하나에 콘텍스트에서 처리하는 것이 빠릅니다.

### ES3의 실행 콘텍스트 환경

1. scope chain
2. Activation Object

### ES5의 실행 콘텍스트 환경

1. scope chain X
2. Activation Object -> Lexcical Environments

> 아키텍처적으로 큰 차이가 납니다. 동적이냐 정적이냐는 것입니다. 엔진에 처리 속도가 많이 납니다.

## 스펙의 scope chain 사용

- 스펙의 scope chain 사용 횟수

  - ES3: 37
  - ES5: 1
  - ES6: 0

- ES5에서 한번 쓴 것도 바뀐 것을 나타내기 위해서 사용했다.
  - Lexical Environment에 Declarative Environment Record에 함수의 변수와 함수 이름을 바인딩한다.(ES3 scope chain에 바인딩했다) -> 하나의 콘텍스트를 가져간다는 것입니다. 이것이 왜 중요하냐? -> 함수가 호출되어 메모리에 올라갈 때, 콘텍스트 하나만 올라가면 된다는 것입니다. 물론, 그것에 맞춰서 프로그램 코드를 작성해야 한다는 전제는 있지만, 기본적으로 아케텍처가 받쳐줍니다. ES3에서는 아키텍처가 받쳐주지 못했습니다. ES5에서는 완전하게 정적환경에서 아키텍처가 받쳐줍니다.
  - 엔진에 처리 속도를 향상하기 위해서는 남아 있는 것은 정적 환경에 선언적 환경 기록에 맞춰서 코드를 작성해주면 된다는 것입니다.

# scope chain 👎🏻 Lexical Environment 👍🏻
