# 오버로딩

```js
console.log("[코드1] 오버로딩 형태");
function book(one) {}
function book(one, two) {}
function book(one, two, three) {}

book(one, two); // error : Uncaught ReferenceError: one is not defined
```

함수 이름이 같더라도 파라미터 수, 타입이 다르면 각각 존재하게 됩니다.

이것을 오버로딩이라고 합니다.

예를 들면, 자바스크립트는 오버로딩을 지원하지 않습니다. 하지만, 오버로딩을 지원하는 언어는 여기에 파라미터 수가 다르거나 값 타입이 다르면 세 개의 함수가 존재하게 됩니다.

따라서 함수를 호출하면 파라미터 수와 값 타입이 같은 함수가 호출됩니다.

그런데 자바스크립트는 오버로딩을 지원하지 않습니다.

이것은 파라미터 수와 값 타입을 구분하지 않고 `{name: value}` 형태로 저장하기 때문에 그렇습니다.

이에 대한 논리를 살펴보겠습니다.

```js
function book2() {
  function getBook() {
    return "책1";
  }
  console.log(getBook()); // 책2
  function getBook() {
    return "책2";
  }
}
book2();
```

## 오버로딩 미지원: 1. 함수 선언문 초기화

마지막 줄에서 book() 함수를 호출합니다.

첫번째 함수 선언문 해석을 실행합니다.

처음 선언문에 할당된 function 오브젝트가 undefined 값이 아니므로 마지막 선언문에 해당하는 function 오브젝트로 값이 바뀌게 됩니다.

`{name: value}` 형태에서 이름이 같고 값이 정상적으로 function 오브젝트이니깐 대체가 됩니다.

## 오버로딩 미지원: 2. 변수 초기화

다시 첫번째 줄로 이동합니다.

함수 표현식 또는 변수를 찾습니다.

그런데 없습니다. 그러면 이 단계는 넘어갑니다.

다시 첫번째 줄로 엔진 컨트롤이 이동하게 됩니다.

## 오버로딩 미지원: 3. 코드 실행

식별자 해결을 해봤는데 함수 선언문 초기화 단계에서 getBook 함수에 할당된 function 오브젝트가 있었습니다.

그래서 그 값인 "책2" 반환합니다.

이와 같은 논리로 자바스크립트는 오버로딩을 지원하지 않습니다.

즉, 키밸류 네임밸류의 프로퍼티인 것입니다. 이것이 자바스크립트의 가장 기본이 되는 구조입니다.
