# Global 오브젝트

## 글로벌 오브젝트

```js
var value = 100;
function book() {
  var point = 200;
  return value;
}
book();
```

`var value = 100;`에서 100을 value 변수에 할당한 것은 value로 검색하여 값을 다시 사용하기 위한 것 입니다.

그런데 함수 안에 변수를 선언하면 변수가 함수에 속하게 되지만 value 변수는 함수 안에 작성하지 않았습니다.

그러면 이것은 오브젝트가 없는 것 입니다. point 변수는 book 오브젝트에 속하게 되지만 value는 오브젝트가 없습니다.

이때, 글로벌 오브젝트에 설정됩니다.

이런 메커니즘을 구현할 수 있는 것은 글로벌 오브젝트가 하나만 있기 때문입니다. 따로 적어주지 않아도 글로벌 오브젝트가 생성되는 것 입니다.

그런데 지금은 굉장히 많은 오브젝트를 사용하게 되고 그러다 보니까 약간의 문제가 발생하지만, 그래도 오브젝트에 속하지 않으면 글로벌 오브젝트에 속하게 된다는 그 자체만으로 접근이 괜찮았습니다.

## 글로벌 오브젝트 특징

```js
// <script src="./abc.js">
var value2 = 100;
function book2() {
  return value + 50;
}
// <script src="./def.js">
console.log(value2); // 100
console.log(book2()); // 150
```

자바스크립트 소스 파일 전체에서 글로벌 오브젝트는 하나만 있습니다.

따라서 new 연산자로 인스턴스를 생성할 수 없습니다.

만약에 new 연산자로 인스턴스를 생성할 수 있다고 한다면 하나만 있다는 전제가 깨지는 것 입니다.

여기서 자바스크립트 소스 파일 전체 기준은 스크립트 엘리멘트에 작성된 모든 코드입니다.

글로벌 오브젝트가 빌트인 오브젝트이긴 합니다. 형체가 없을 뿐

결론적으로 글로벌 오브젝트는 존재하며 하나만 있는 것 입니다.

def.js 파일의 코드에서 글로벌 오브젝트에 작성된 value 값을 출력하고 book() 함수를 호출할 수 있습니다.

결국 value라는 것이 어느 스코프에 저장이 됩니다. 그것이 바로 글로벌 오브젝트라는 것 입니다. 찾을 때 글로벌 오브젝트에 가서 value 변수를 찾는 것 입니다. 식별자 해결을 하는 것 입니다. 있으면 출력합니다.

book 함수를 호출하면 글로벌 오브젝트에 설정되어 있으면 가서 식별자 해결을 하는 것 입니다. 그것이 함수였고 호출합니다.

book 함수를 호출하기 위해서는 우선 식별자 해결을 해야 합니다. 그러면 식별자 해결을 위해서는 스코프가 있어야 합니다. 바로 글로벌 오브젝트가 스코프라는 것 입니다.
