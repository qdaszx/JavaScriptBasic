# Global 스코프

## 글로벌 스코프

글로벌 오브젝트가 글로벌 스코프입니다.

글로벌 오브젝트가 하나만 있으니까 글로벌 스코프도 하나만 있는 것 입니다.

여기서 오브젝트는 개발자 관점으로 오브젝트에 함수와 변수를 작성합니다.

즉 함수와 변수를 작성하기 위해서는 오브젝트가 있어야 합니다.

그런데, 글로벌 오브젝트는 오브젝트가 없습니다.

물론, 오브젝트는 없지만 window 오브젝트를 글로벌 오브젝트로 사용하긴 합니다.

하지만, Number 오브젝트, String 오브젝트 같이 글로벌 오브젝트가 있는 것은 아닙니다.

따라서 함수와 변수를 작성하면 글로벌 오브젝트에 설정되어야 하지만, window 오브젝트에 설정됩니다.

또한 스코프는 식별자 해결을 위한 것으로 엔진 처리 관점입니다.

엔진이 식별자 해결을 위해서 스코프를 사용한다는 것 입니다.

그리고 개발자는 함수와 변수를 작성하기 위해서 오브젝트를 사용하는 것 입니다.

그리고 글로벌 스코프는 최상위 스코프입니다.

함수에서 보면 최종 스코프가 되는 것 입니다.

이것은 함수 안에 A 함수가 있고 그 안에 B 함수가 있고 그 안에 C 함수가 있다고 했을 때, C 함수에서 변수를 식별자 해결을 할려고 합니다. 그런데 없으면, 밖으로 나가서 B 함수 스코프에서 찾습니다. 그리고 B 함수 스코프에 없으면 다시 올라가게 되는데, 최종적으로 올라간 곳이 최종 스코프라는 것 입니다.

즉, 식별자 해결을 위해서 스코프를 계층적으로 따라 올라가다가 마지막으로 만나는 곳이 글로벌 스코프라는 것 입니다.

이와 같이 스코프는 식별자 개념으로 접근한 것이고, 오브젝트는 함수와 변수 작성 개념으로 접근한 것 입니다.

```js
var value = 100;
function book() {
  return value;
}
book();
```

글로벌 스코프를 코드를 따라가면서 하나씩 과정을 살펴보자.

엔진이 처음 코드를 만나게 되면 함수 선언문을 찾습니다.

`function book(){코드}`를 만나게 됩니다.

book 함수가 속한 오브젝트가 없으므로 function 키워드로 만든 function 오브젝트를 글로벌 오브젝트로 설정합니다.

이것을 글로벌 함수라고 합니다.

그런데, 글로벌 함수를 전역 함수라고 합니다만 이름이 글로벌 오브젝트이니까 글로벌 함수가 시맨틱에 어울립니다.

다시 돌아와서 value 변수를 초기화 합니다.

value 변수가 글로벌 오브젝트에 설정됩니다.

이것을 글로벌 변수라고 합니다. 전역 변수라고 합니다만 시맨틱 차이가 있습니다.

이렇게 글로벌 오브젝트에 설정된다는 것은 오브젝트 관점입니다.

스코프와 식별자 해결 관점에서 본다면 Scope가 글로벌 스코프라는 것 입니다.

book(); book 함수를 호출하게 되는데, book 함수를 호출할려면 "오브젝트.book()" 형태로 작성해야 됩니다.

그런데 오브젝트를 작성하지 않고 함수만 작성했습니다.

오브젝트를 작성하지 않으면 글로벌 오브젝트를 "오브젝트"로 간주합니다.

그리고 글로벌 오브젝트의 book() 함수를 호출하게 됩니다.

사실 글로벌 오브젝트의 실체가 없습니다. 그러나 Host 오브젝트 개념으로 Window 오브젝트를 사용합니다. 따라서 Window 오브젝트의 book 함수를 호출한다고도 할 수 있습니다.

여기서 book 함수를 호출할려면 우선 식별자 해결을 해야 합니다.

그런데 식별자 해결을 할려면 스코프가 있어야 하는데, 여기는 글로벌 오브젝트에 작성되어 있습니다.

따라서 글로벌 스코프에서 book 함수를 찾아서 즉, 식별자 해결을 해서 존재함으로 해결하게 됩니다.

> 글로벌 오브젝트와 글로벌 스코프는 같습니다. 그러나 **오브젝트는 개발자 관점에서 함수와 변수로 접근**한 것이고, **스코프는 식별자 해결을 위해서 엔진 관점에서 접근**한 것 입니다.

그래서 오브젝트라고 쓰는 것과 스코프라고 쓰는 것은 이미 전제가 다른 것 입니다.
