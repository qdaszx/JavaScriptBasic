# 스코프 바인딩

## 바인딩

바인딩이란 구조적으로 결속된 상태로 만드는 것 입니다.

바인딩의 대상은 프로퍼티 이름입니다.

여기서 프로퍼티란 변수 이름과 값, 함수 이름과 값

값은 변함으로 이름이 대상이 됩니다.

바인딩의 목적은 스코프를 설정하는 것 입니다.

그리고 식별자 해결을 하는 것 입니다.

바인딩 시점 구분은 정적 바인딩(Lexical, Static Binding)과 동적 바인딩 (Dynamic Binding)으로 나뉩니다.

## 정적, 동적 바인딩

정적(렉시컬) 바인딩은 함수가 호출 되었을 때 초기화 단계에서 바인딩합니다.

이때 함수 선언문의 이름을 바인딩합니다.

변수와 함수 이름을 바인딩 합니다.

자바스크립트는 대부분 정적 바인딩을 합니다.

하지만, 동적(다이나믹) 바인딩하는 것이 있습니다.

이것은 실행 할 때 바인딩합니다. eval()함수, with문

## 바인딩 시점의 중요성

바인딩 시점이 중요한 이유는 바인딩할 때 스코프가 결정되기 때문입니다.

function 오브젝트 생성 시점에 스코프가 결정됩니다.

스코프를 생성한 function 오브젝트의 내부 프로퍼티인 `[[Scope]]`에 설정합니다.

**가장 중요한 것은 스코프가 변경되지 않습니다.**

그래서 정적 스코프인 것 입니다.

함수 안의 모든 스코프가 같습니다.

```js
function book() {
  var point = 100;
  function add() {
    point += 200;
  }
  function get() {
    return point;
  }
}
```

book 함수 안의 add 함수와 get 함수가 있습니다.

그런데 add function 오브젝트를 생성하는 시점에 스코프를 내부 프로퍼티인 `[[Scope]]`에 설정하는 것 입니다.

즉, 내부 프로퍼티인 `[[Scope]]`에 book 함수 안의 전체 코드가 설정됩니다.

get 함수도 마찬가지도 function 오브젝트를 만드는 시점에 book 함수 안의 전체 코드가 내부 프로퍼티인 `[[Scope]]`에 설정합니다.

그런데 이것을 정적으로 한다는 것 입니다.

따라서 add 함수에서 포인트를 공유할 수 있는 것 입니다.

왜냐하면, book 함수 안의 전체 코드가 하나의 스코프이기 때문입니다.

따라서 add 함수에서 point에 200을 더하고 그리고 get 함수에서 point를 사용해서 반환하게 된다면 300이 반환됩니다.

스코프 개념 때문에 그렇습니다.

이 환경을 내부 프로퍼티인 `[[Scope]]`에 설정하기 때문에 그렇습니다.

그리고 이것은 변경되지 않기 때문에 그렇습니다.

## 스코프 바인딩

```js
function book() {
  var point = 100;
  function add(param) {
    point += param;
  }
  var get = function () {
    return point;
  };
  add(200);
  console.log(get()); // 300
}
book();
```

book() 함수를 호출합니다.

함수 안으로 엔진 컨트롤이 이동합니다.

초기화 단계에서 함수와 변수 이름을 선언적 환경 레코드에 바인딩 합니다.

function add(param){...}을 먼저 만나서 function 오브젝트를 생성하고 add 함수가 속한 스코프(영역)를 add 오브젝트의 내부 프로퍼티인 `[[Scope]]`에 설정합니다.

그리고 add 이름을 선언적 환경 레코드에 바인딩 합니다.

그 다음 함수 선언문이 없기 때문에 다시 첫줄로 올라갑니다.

var point = 100;을 만나게 됩니다. point 이름을 선언적 환경 레코드에 바인딩 합니다.

이때 값은 undefined로 설정 됩니다.

그리고 내려오면 var get = function(){...}이 있습니다.

똑같이 get: undefined로 선언적 환경 레코드에 바인딩 합니다.

여기까지 함으로써 바인딩이 끝난 것 입니다.

그래서 이때 바인딩으로 인해 함수와 변수의 식별자가 해결됩니다.

비록 변수는 값이 다를 지 언정 변수 이름이 없어서 에러가 나는 것은 아닙니다.

다시 코드 실행으로 첫줄로 올라갑니다.

그러면 point는 100으로 할당합니다.

get 변수에 function 키워드를 만나게 됩니다. 그러면 function 오브젝트를 만들어서 get 변수에 할당합니다.

그리고 get 변수가 속한 스코프(영역)를 get 오브젝트의 내부 프로퍼티인 `[[Scope]]`에 설정합니다.

다음 add 함수를 호출합니다

add 함수 안으로 들어갑니다. point += param; 코드를 만나게 됩니다.

이때 point는 선언적 환경 레코드에서 찾습니다. 선언적 환경 레코드에는 함수 안에 작성된 함수와 변수가 들어 있습니다.

그런데 없다면? 다시 검색하게 됩니다. 이때는 add 오브젝트의 내부 프로퍼티인 `[[Scope]]`에 가서 이것을 스코프로 사용해서 여기서 검색하게 됩니다.

point 변수가 있기에 그 값을 사용할 수 있습니다.

param 파라미터 200값과 point 변수 값인 100을 더해서 point는 300이 되는 것 입니다.

내가 만든 변수가 아니라 함수 밖에 있는 것도 이와 같이 값을 변경할 수 있는 것 입니다.

왜냐하면 함수가 속한 스코프를 내부 프로퍼티인 `[[Scope]]`에다가 설정해놓고 마치 내 것처럼 쓰기 때문입니다.

point는 add 함수의 소유는 아닙니다. 왜냐하면 밖에 있기 때문입니다.

add 함수의 소유라면 add 함수 안에 작성해야 합니다.

그런데 이것은 밖인데도 사용할 수 있는 메커니즘은 내부 프로퍼티 `[[Scope]]`에 스코프를 설정하기 때문입니다.

그리고 콘솔에 get()을 호출하게 됩니다.

그러면 get 변수쪽으로 엔진이 이동하는데 함수 안에 포인트를 선언하지 않았기에 point가 없습니다.

이것을 내부 프로퍼티인 `[[Scope]]`에서 찾습니다.

그러면 있습니다.

하지만 값은 300입니다.

여기서 point 변수를 add 함수와 get 함수에서 공유 했다는 것 입니다.

왜냐하면 이것이 같은 스코프를 갖고 있기 때문입니다.

## 동적 바인딩

동적 바인딩이란 코드를 실행할 때마다 바인딩 하는 것 입니다.

with문, eval() 함수가 있습니다.

with문은 use strict 환경에서 에러가 발생합니다.

eval() 함수는 보안에 문제가 있습니다.
