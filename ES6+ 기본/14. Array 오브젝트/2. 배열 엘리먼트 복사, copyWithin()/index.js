/*
배열 엘리먼트 복사

구분 ::: 데이터(값)
형태 ::: Array.prototype.copyWithin()
파라미터 ::: 1. 복사한 값을 설정할 시작 인덱스 2. 복사 시작 인덱스opt 3. 복수 끝 인덱스opt
반환 ::: 변경된 Array 오브젝트

- 범위 값을 복사하여 같은 오브젝트에 설정

- 두 번째 파라미터의 인덱스부터 복사하여 첫 번째 파라미터 인덱스부터 순서대로 설정(대체) [코드1]

- 세 번째 파라미터의 인덱스 직전까지 복사 [코드2]

- 복사 시작 인덱스와 끝 인덱스를 작성하지 않으면 배열 전체 복사 [코드3]
*/
console.log("[코드1] 3번째 파라미터를 작성하지 않음");
const list = ["A", "B", "C", "D", "E"];
const copy = list.copyWithin(1, 3);
console.log(list);  // ['A', 'D', 'E', 'D', 'E']
console.log(copy);  // ['A', 'D', 'E', 'D', 'E']
/**
 * 1. list 배열이 대상입니다.
 * 2. 두 번째 파라미터의 3번 인덱스부터 배열의 끝까지 복사하여
 * 3. 첫 번째 파라미터의 1번 인덱스부터 차례로 설정
 * 4. D와 E를 복사하므로 엘리먼트가 2개이며
 * 5. 1번 인덱스부터 2개를 대체하므로 B가 D로, C가 E로 대체됩니다.
 * 6. 복사 대상에 대체하므로 반환된 Array 오브젝트와 복사 대상이 같습니다.
 */

console.log("[코드2] 3번째 파라미터 작성");
const list2 = ["A", "B", "C", "D", "E"];;
list2.copyWithin(0, 2, 4);;
console.log(list2); // ['C', 'D', 'C', 'D', 'E']
/**
 * 1. 두 번째 파라미터의 2번 인덱스부터
 * 2. 세 번째 파라미터의 4번 인덱스 직전까지 복사하여 list 배열의 0번 인덱스부터 설정
 * 3. 2번 인덱스, 3번 인덱스를 복사하므로 C와 D를 복사하게 됩니다.
 * 4. A가 C로, B가 D로 대체됩니다.
 */

console.log("[코드3] 2번째, 3번째 파라미터를 작성하지 않음");
const list3 = ["A", "B", "C", "D", "E"];
list3.copyWithin(3);
console.log(list3); // ['A', 'B', 'C', 'A', 'B']
/**
 * 1. list 배열 전체가 복사 대상입니다.
 * 2. 3번 인덱스부터 대체합니다.
 * 3. 복사할 엘리먼트 수가 대체할 엘리먼트 수보다 많으면
 * 4. 매치되는 인덱스만 값을 대체하고 남는 것은 대체하지 않습니다.
 * 5. D가 A로, E가 A로 대체됩니다.
 */

/*
copyWithin() 함수의 특징

- shallow copy(얕은 복사)
- 같은 배열 안에서 이동하는 개념 [코드4]
- 배열의 엘리먼트 수가 변동되지 않음

배열 안에서 엘리먼트를 이동은

- 엘리먼트를 왼쪽, 오른쪽으로 이동하는 것
- 처리 속도가 빠름
*/
console.log("[코드4] 특징");
const list4 = ["A", { B: "가" }, "C"];
console.log(list4.copyWithin(0, 1)) // [{B: '가'}, C, C]
/**
 * 1. {B: "가"}를 복사할 때 새로운 {B: "가"}를 만들지 않고 현재의 메모리 주소를 복사합니다.
 * 2. shallow copy(얕은 복사)라고 합니다.
 * 3. shallow copy는 값이 연동됩니다.
 * 4. 연동되지 않도록 하려면 Deep Copy를 해야 합니다.
 */