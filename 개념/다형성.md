> 다형성에 대한 개념을 공부하기 위해서 기록합니다. (예시 언어: 자바)

# 다형성의 개념

## 다형성(polymorphism) 이란?

다형성(polymorphism)이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미합니다.

자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있습니다.

다형성은 상속, 추상화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나입니다.

---

## 참조 변수의 다형성

자바에서는 다형성을 위해 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하고 있습니다.

이때 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 같거나 적어야 참조할 수 있습니다.

다음 예제는 참조 변수의 다형성을 보여주는 예제입니다.

```java
class Parent { ... }

class Child extends Parent { ... }

...

Parent pa = new Parent(); // 허용

Child ch = new Child();   // 허용

Parent pc = new Child();  // 허용

Child cp = new Parent();  // 오류 발생.
```

특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있습니다.

참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문입니다.

그리고 부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있습니다.

참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 적기 때문입니다.

하지만 반대의 경우 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없습니다.

참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문입니다.

> 📖 클래스는 상속을 통해 확장될 수는 있어도 축소될 수는 없으므로, 자식 클래스에서 사용할 수 있는 멤버의 개수가 언제나 부모 클래스와 같거나 많게 됩니다.

## 참조 변수의 타입 변환

자바에서는 참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있습니다.

1. 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있습니다.
2. 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략할 수 있습니다.
3. 하지만 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 합니다.

참조 변수의 타입 변환도 기본 타입의 타입 변환과 마찬가지로 타입 캐스트 연산자 (())를 사용합니다.

문법:
(변환할 타입의 클래스 이름) 변환할 참조 변수

다음 예제는 참조 변수의 타입 변환을 보여주는 예제입니다.

```java
class Parent { ... }
class Child extends Parent { ... }
class Brother extends Parent { ... }

...

Parent pa01 = null;
Child ch = new Child();
Parent pa02 = new Parent();
Brother br = null;


pa01 = ch;          // pa01 = (Parent)ch; 와 같으며, 타입 변환을 생략할 수 있음.
br = (Brother)pa02; // 타입 변환을 생략할 수 없음.
br = (Brother)ch;   // 직접적인 상속 관계가 아니므로, 오류 발생.
```

---

## instanceof 연산자

이러한 다형성으로 인해 런타임에 참조 변수가 실제로 참조하고 있는 인스턴스의 타입을 확인할 필요성이 생깁니다.

자바에서는 instanceof 연산자를 제공하여, 참조 변수가 참조하고 있는 인스턴스의 실제 타입을 확인할 수 있도록 해줍니다.

자바에서 instanceof 연산자는 다음과 같이 사용합니다.

문법:
참조 변수 **instanceof** 클래스 이름

왼쪽에 전달된 참조 변수가 실제로 참조하고 있는 인스턴스의 타입이 오른쪽에 전달된 클래스 타입이면 true를 반환하고, 아니면 false를 반환합니다.

만약에 참조 변수가 null을 가리키고 있으면 false를 반환합니다.

다음 예제는 참조 변수가 실제로 가리키고 있는 인스턴스의 타입을 instanceof 연산자로 확인하는 예제입니다.

```java
class Parent { }
class Child extends Parent { }
class Brother extends Parent { }

public class Polymorphism01 {
    public static void main(String[] args) {
        Parent p = new Parent();
        System.out.println(p instanceof Object); // true
        System.out.println(p instanceof Parent); // true
        System.out.println(p instanceof Child);  // false
        System.out.println();

        Parent c = new Child();
        System.out.println(c instanceof Object); // true
        System.out.println(c instanceof Parent); // true
        System.out.println(c instanceof Child);  // true
    }
}
```

Reference:

[http://www.tcpschool.com/java/java_polymorphism_abstract](http://www.tcpschool.com/java/java_polymorphism_abstract)

---

> 다형성에 대해서 설명하시오

객체지향 프로그래밍의 특징 중 하나인 다형성(polymorphis)은 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해주고, 같은 클래스 내에 코드의 길이를 줄여주는 것까지 도와주는 개념입니다.

관용적인 개념의 다형성은 같은 모양의 코드가 다른 행위를 하는 것을 나타냅니다.

우리가 핸드폰에 있는 키패드로 다이얼을 누르기도 하고, 문자를 하기도 하며, 심지어 게임을 하는 것까지 가능한 것처럼 모양은 같은데 다른 기능을 수행하는 것은 디바이스 기반의 다형성의 한 예라고 할 수 있습니다.

같은 맥락에서 자바 프로그래밍에 이 다형성의 개념을 녹여내는 방법은 두 가지가 있습니다. 비슷한 이름이지만 전혀 다른 개념이니 헷갈리지 않도록 주의해야 합니다.

## Overriding

오버 라이딩은 슈퍼 클래스를 상속 받은 서브 클래스에서 슈퍼 클래스의 (추상) 메소드를 같은 이름, 같은 반환 값, 같은 인자로 메소드 내의 로직들을 새롭게 정의하는 것을 말합니다.

이를 이용하면 하나의 슈퍼 클래스를 상속받는 여러 서브 클래스들이 같은 이름에 다른 기능을 하는 메소드를 정의하고 사용하게끔 할 수 있습니다.

오버 라이딩을 이용해서 같은 이름이지만 구현하는 클래스마다 다른 역할을 하는 메소드를 정의하고 있죠? 마치 키패드라는 모양을 가졌지만 게임을 하고, 문자를 보내는 것처럼 말이죠.

## Overloading

오버 로딩은 하나의 클래스에서 같은 이름의 메소드들을 여러 개 가질 수 있게 합니다. 단, 메서드 인자들은 달라야 합니다. (반환 타입은 같아도 되고 달라도 됩니다.)

인자들의 타입이나 개수가 다르면 메소드 이름이 같더라도 어떤 메소드를 호출할지 컴파일러가 알 수 있기 때문입니다.

그런데 왜 굳이 이렇게 같은 클래스 내에서 메소드 이름을 같게 주는 것일까요?

유사한 일을 수행하면서 인자만 다른 메소드들에 대해 각기 다른 이름을 준다면 사용하기 매우 불편할 것입니다.

마치 키패드에 문자용 키패드를 따로 만들고, 게임용 키패드를 따로 만드는 것처럼 비효율적인 것이죠.

다형성의 개념을 물어보는 질문들은 보통 OOP가 왜 다형성을 구현했는지, 어떻게 구현했는지 물어보는 게 핵심이고 추가적으로 오버라이딩과 오버로딩의 특징에 대해서 잘 알고 있냐는 확인하는 질문이기도 합니다.

Reference:

[https://brunch.co.kr/@kd4/4](https://brunch.co.kr/@kd4/4)
